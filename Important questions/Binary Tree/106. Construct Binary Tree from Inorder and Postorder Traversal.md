# 106. Construct Binary Tree from Inorder and Postorder Traversal

## è§£é¡Œç¨‹å¼ç¢¼

### æ™‚é–“è¤‡é›œåº¦: O(n^2) è§£æ³•

```javascript
var buildTree = function (inorder, postorder) {
  if (!inorder.length) return null;

  const root = new TreeNode(postorder.pop());
  const mid = inorder.indexOf(root.val);
  // è¦å…ˆçµ„å‡ºå³å­æ¨¹çš„éƒ¨åˆ†ï¼Œå› ç‚ºèµ·åˆçš„ postorder å€’æ•¸ç¬¬äºŒå€‹ç¯€é»æ˜¯æ ¹ç¯€é»çš„å³å­æ¨¹ç¯€é»
  root.right = buildTree(inorder.slice(mid + 1), postorder);
  root.left = buildTree(inorder.slice(0, mid), postorder);

  return root;
};
```

### æ™‚é–“è¤‡é›œåº¦: O(n) è§£æ³•

ä½¿ç”¨ hashMap å„²å­˜å„ç¯€é»å’Œå…¶ç´¢å¼•ã€‚

```javascript
var buildTree = function (inorder, postorder) {
  if (!inorder.length) return null;

  const hashMap = new Map();

  for (let i = 0; i < inorder.length; i++) {
    hashMap.set(inorder[i], i);
  }

  const DFS = (start, end) => {
    if (start > end) return null;
    const root = new TreeNode(postorder.pop());
    const mid = hashMap.get(root.val);
    root.right = DFS(mid + 1, end);
    root.left = DFS(start, mid - 1);

    return root;
  };

  return DFS(0, inorder.length - 1);
};
```

## è§£é¡Œæ€è·¯ã€æ¼”ç®—æ³•

å’Œ 105 é¡Œç›¸ä¼¼ï¼Œä¸éæ˜¯è¦æ±‚å¾**å¾Œ**åºèµ°è¨ªã€ä¸­åºèµ°è¨ªå¾Œçš„çµæœï¼Œå»çµ„å»ºå‡ºåŸæœ¬çš„äºŒå…ƒæ¨¹ï¼Œæ‰€ä»¥éœ€è¦ä¾ç…§å®ƒå€‘æ’åºçš„ç‰¹æ€§å»æƒ³è¾¦æ³•æ‰¾å‡ºåŸæœ¬çš„äºŒå…ƒæ¨¹ã€‚

### ç‰¹æ€§: postorder æœ€å¾Œä¸€å€‹ç¯€é»ä¸€å®šæ˜¯ Tree æ ¹ç¯€é»

> Inorder: `<LEFT><ROOT><RIGHT>`, postorder: `<LEFT><RIGHT><ROOT>`

> slice() çš„ç”¨æ³•è¤‡ç¿’ä¸€ä¸‹

## è§£æ³•çš„æ™‚é–“ã€ç©ºé–“è¤‡é›œåº¦

æ™‚é–“è¤‡é›œåº¦: O(n)ï¼Œå„ªåŒ–å¾Œ
ç©ºé–“è¤‡é›œåº¦: O(n)

## åƒè€ƒè³‡æ–™

[Construct Binary Tree from Inorder and Postorder Traversal - Leetcode 106 - Python](https://youtu.be/vm63HuIU7kw)

[ğŸ’¡JavaScript Solution](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/491447/javascript-solution/?envType=study-plan-v2&envId=top-interview-150)
> æœ‰åœ–å¯åƒè€ƒ
