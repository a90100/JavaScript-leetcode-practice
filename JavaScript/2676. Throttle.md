# 2676. Throttle

## 解題程式碼

解法 1. 最貼近自己的思路

主要就是記錄 prevTime 算出要多久之後才去執行這次呼叫的函式，並且用 timeId 記錄前一次呼叫的 timeout id，

這樣連續觸發 fn 時，就能夠移除當前的 timeout，保證只有符合時間內的 fn 才被執行。

```javascript
var throttle = function (fn, t) {
  let prevTime = 0;
  let timeId = null;

  return function (...args) {
    const curTime = new Date().getTime();
    let remain = Math.max(t - (curTime - prevTime), 0);

    clearTimeout(timeId);

    timeId = setTimeout(() => {
      fn(...args);
      prevTime = new Date().getTime();
    }, remain);
  };
};
```

解法 2.

和 [Throttle - Leetcode 2676 - JavaScript 30-Day Challenge](https://youtu.be/zyGZV_fIQWk) 相似。

思路是這個 throttle 有兩種狀態：looping 和 waiting，

timeoutInProgress 非 null 代表還在 looping，若還在 looping 就呼叫 fn，並更新傳入參數，

若是 waiting，可以直接執行 fn 並且修改 timeoutInProgress，代表進入 looping，

經過 t 時間後，執行 timeoutFunction，分成兩種情況，

若在上一次呼叫函式後的時間到之後的 t 時間範圍內，有函式被呼叫，argsToProcess 不會為 null，

所以執行 fn 並清空參數，修改 timeoutInProgress，代表再次進入 looping，

反之若在上一次呼叫函式後的時間到之後的 t 時間範圍內，argsToProcess 會為 null，

清空 timeoutInProgress，代表進入 waiting。

> timeoutInProgress 也可以用一個 boolean 取代

```javascript
var throttle = function (fn, t) {
  let timeoutInProgress = null;
  let argsToProcess = null;

  const timeoutFunction = () => {
    if (argsToProcess === null) {
      timeoutInProgress = null; // enter the waiting phase
    } else {
      fn(...argsToProcess);
      argsToProcess = null;
      timeoutInProgress = setTimeout(timeoutFunction, t);
    }
  };

  return function throttled(...args) {
    if (timeoutInProgress) {
      argsToProcess = args;
    } else {
      fn(...args); // enter the looping phase
      timeoutInProgress = setTimeout(timeoutFunction, t);
    }
  };
};
```

解法 3. setTimeout 改用 setInterval + clearInterval

```javascript
var throttle = function (fn, t) {
  let intervalInProgress = null;
  let argsToProcess = null;

  const intervalFunction = () => {
    if (argsToProcess === null) {
      clearInterval(intervalInProgress);
      intervalInProgress = null; // enter the waiting phase
    } else {
      fn(...argsToProcess);
      argsToProcess = null;
    }
  };

  return function throttled(...args) {
    if (intervalInProgress) {
      argsToProcess = args;
    } else {
      fn(...args); // enter the looping phase
      intervalInProgress = setInterval(intervalFunction, t);
    }
  };
};
```

解法 4. 和解法 1 類似

```javascript
var throttle = function (fn, t) {
  let timeout = null;
  let nextTimeToCallFn = 0;
  return function (...args) {
    const delay = Math.max(0, nextTimeToCallFn - Date.now());
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn(...args);
      nextTimeToCallFn = Date.now() + t;
    }, delay);
  };
};
```

## 解題思路、演算法

## 參考資料
