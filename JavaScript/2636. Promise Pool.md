# 2636. Promise Pool

## 解題程式碼

解法 1.

```javascript
var promisePool = async function (functions, n) {
  return new Promise((resolve) => {
    let index = 0;
    let resolveNum = 0;
    const helper = () => {
      if (resolveNum === functions.length) resolve();

      while (n && index < functions.length) {
        functions[index]().then((res) => {
          n++;
          resolveNum++;
          helper();
        });
        n--;
        index++;
      }
    };
    helper();
  });
};
```

解法 2.

[Promise Pool - Leetcode 2636 - JavaScript 30-Day Challenge](https://youtu.be/DB8pAAg-9xw) 的第二個解法。

取 n 個非同步函式丟給 Promise.all，Promise.all 會執行所有非同步函式，

`await functions[i++]()` 執行函式，並且 i + 1，當中若有非同步函式執行完，執行到下一行，

再次呼叫 callback 函式，並執行下一個非同步函式。

```javascript
var promisePool = async function (functions, n) {
  let i = 0;

  async function callback() {
    if (i === functions.length) return;

    await functions[i++]();
    await callback();
  }

  const nPromises = new Array(n).fill().map(callback);
  await Promise.all(nPromises);
};
```

解法 3. 和上面相似，不用 i 變數，而是用 `shift()` 取代。

```javascript
var promisePool = async function (functions, n) {
  async function evaluateNext() {
    if (functions.length === 0) return;
    const fn = functions.shift();
    await fn();
    await evaluateNext();
  }
  const nPromises = Array(n).fill().map(evaluateNext);
  await Promise.all(nPromises);
};
```

解法 4.

1. 使用 n 作為當前的索引
2. 使用 optional chaining，當所有非同步函式都執行完，變成 undefined
3. 使用 promise chaining 取代 await
4. 用 `slice()` 取出 n 個非同步函式後，要馬上執行，所以用 `map()` 遍歷每個非同步函式並執行

```javascript
var promisePool = async function (functions, n) {
  const evaluateNext = () => functions[n++]?.().then(evaluateNext);
  return Promise.all(functions.slice(0, n).map((f) => f().then(evaluateNext)));
};
```

## 解題思路、演算法

自己練習時，已經很接近解法 1. 了，但有個重點沒想到：

為了重複執行 **是否已經執行完全部非同步函式的 if 判斷式和 while 迴圈**，要記得用 `helper()` 函式，當一個非同步任務完成時重複執行上述邏輯。

## 參考資料

[@supercharge/promise-pool](https://www.npmjs.com/package/@supercharge/promise-pool)

> 相關套件

這類功能的使用情境例如，一次要下載很多檔案時，可能會因為一些原因無法負載：

1. The environment may cancel requests because it detects that there are too many to handle.
2. The database may become unresponsive under the heavy load.
3. Too much network traffic could cause higher priority requests to get delayed.
4. The app could become unresponsive trying to process all the data at once.

所以透過 promise-pool 來限制非同步函式處理的數量。
